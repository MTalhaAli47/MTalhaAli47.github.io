<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AES-128 Round‑1 Visualizer (Detailed Step-by-Step)</title>
  <style>
    /* Dark modern theme styling */
    body{
      font-family: Inter, system-ui, 'Segoe UI', Roboto, Helvetica, Arial;
      margin: 18px;
      color: #f0f0f0;
      background: #0f111a;
    }
    h1{
      font-size: 24px;
      color: #00d8ff;
      margin-bottom: 10px;
      text-align: center;
    }
    .small{
      font-size: 14px;
      color: #aaa;
      max-width: 900px;
      margin: 0 auto 20px auto;
      text-align: center;
    }
    label{
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
      color: #fff;
    }
    input[type=text]{
      width: 380px;
      padding: 10px;
      font-family: monospace;
      border-radius: 6px;
      border: 1px solid #555;
      background: #1a1c29;
      color: #fff;
    }
    button{
      padding: 10px 14px;
      margin-left: 6px;
      border-radius: 6px;
      border: none;
      background: linear-gradient(135deg, #00d8ff, #0066ff);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover{
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.4);
      background: linear-gradient(135deg, #0066ff, #00d8ff);
    }
    .error{
      color: #ff4d4d;
      margin-top: 8px;
      font-weight: 600;
    }
    .grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(280px,1fr));
      gap:18px;
      margin-top:20px;
    }
    .card{
      border-radius:12px;
      padding:16px;
      background: linear-gradient(145deg, #1a1c29, #11131f);
      box-shadow:4px 4px 12px rgba(0,0,0,0.5), -4px -4px 12px rgba(255,255,255,0.05);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .card:hover{
      transform: translateY(-5px);
      box-shadow:6px 6px 20px rgba(0,0,0,0.6), -6px -6px 20px rgba(255,255,255,0.05);
    }
    .label{
      font-weight:700;
      margin-bottom:10px;
      font-size:15px;
      color:#00d8ff;
    }
    table{
      border-collapse:collapse;
      width:100%;
      table-layout:fixed;
    }
    td{
      border:1px solid #333;
      padding:10px;
      text-align:center;
      font-family: monospace;
      color: #fff;
      background: #1a1c29;
      font-weight: 500;
    }
    pre{
      background: #11131f;
      padding:10px;
      border-radius:8px;
      border:1px solid #222;
      overflow-x:auto;
      font-family: monospace;
      font-size:13px;
      color: #ddd;
    }
    details{ margin-top: 10px; }
    summary{
      font-weight:700;
      cursor:pointer;
      color:#00d8ff;
    }
    .mono{ font-family: monospace; word-break: break-word; color: #fff; }
    @media (max-width:600px){ input[type=text]{width:100%;} }
  </style>
</head>
<body>
  <h1>AES-128 Round‑1 Visualizer — Full Calculations</h1>
  <p class="small">Enter 128-bit plaintext and key as 32 hex characters (16 bytes). This version prints every intermediate arithmetic step (SubBytes mapping, ShiftRows indexes, MixColumns GF(2^8) multiplies/XORs, KeyExpansion RotWord/SubWord/Rcon and AddRoundKey XORs) so you can verify each byte calculation.</p>

  <div>
    <label>Plaintext (128-bit hex, 32 hex chars): </label><br>
    <input id="pt" type="text" value="00112233445566778899aabbccddeeff" />
  </div>
  <div style="margin-top:8px">
    <label>Key (128-bit hex, 32 hex chars): </label><br>
    <input id="key" type="text" value="000102030405060708090a0b0c0d0e0f" />
    <button id="run">Run</button>
    <button id="fillExample">Fill Example</button>
  </div>
  <div id="err" class="error"></div>

  <div class="grid" id="out">
    <!-- cards injected here -->
  </div>

  <div id="details" style="margin-top:14px"></div>

<script>
// Utility helpers
const hexByte = b => (b>>>0).toString(16).padStart(2,'0');
const parseHex = s => { s = s.replace(/\s+/g,'').toLowerCase(); if(s.length !== 32 || /[^0-9a-f]/.test(s)) return null; const bytes=[]; for(let i=0;i<32;i+=2) bytes.push(parseInt(s.substr(i,2),16)); return bytes; }
function bytesToState(bytes){ const st = Array.from({length:4},()=>Array(4).fill(0)); for(let col=0; col<4; col++) for(let row=0; row<4; row++) st[row][col] = bytes[4*col + row]; return st; }
function stateToBytes(state){ const out=[]; for(let col=0;col<4;col++) for(let row=0;row<4;row++) out.push(state[row][col]); return out; }
function cloneState(s){ return s.map(r=>r.slice()); }
function showMatrix(title,state,container){ const div=document.createElement('div'); div.className='card'; div.innerHTML=`<div class='label'>${title}</div>`; const table=document.createElement('table'); for(let r=0;r<4;r++){ const tr=document.createElement('tr'); for(let c=0;c<4;c++){ const td=document.createElement('td'); td.textContent = hexByte(state[r][c]); tr.appendChild(td);} table.appendChild(tr);} div.appendChild(table); container.appendChild(div); }

// S-box
const sbox=[
0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16];

function subBytes(state){ const out=cloneState(state); for(let r=0;r<4;r++) for(let c=0;c<4;c++) out[r][c]=sbox[out[r][c]]; return out; }
function shiftRows(state){ const out=cloneState(state); for(let r=0;r<4;r++) for(let c=0;c<4;c++) out[r][c] = state[r][(c + r)%4]; return out; }
function xtime(a){ return ((a<<1) & 0xff) ^ ((a & 0x80) ? 0x1b : 0x00); }
function mul(a,b){ if(b===1) return a; if(b===2) return xtime(a); if(b===3) return xtime(a) ^ a; let res=0, aa=a, bb=b; while(bb){ if(bb&1) res ^= aa; aa = xtime(aa); bb >>=1; } return res & 0xff; }
function mixColumns(state){ const out=cloneState(state); for(let c=0;c<4;c++){ const a0=state[0][c],a1=state[1][c],a2=state[2][c],a3=state[3][c]; out[0][c] = (mul(a0,2) ^ mul(a1,3) ^ mul(a2,1) ^ mul(a3,1)) & 0xff; out[1][c] = (mul(a0,1) ^ mul(a1,2) ^ mul(a2,3) ^ mul(a3,1)) & 0xff; out[2][c] = (mul(a0,1) ^ mul(a1,1) ^ mul(a2,2) ^ mul(a3,3)) & 0xff; out[3][c] = (mul(a0,3) ^ mul(a1,1) ^ mul(a2,1) ^ mul(a3,2)) & 0xff; } return out; }
function addRoundKey(state, roundKeyState){ const out=cloneState(state); for(let r=0;r<4;r++) for(let c=0;c<4;c++) out[r][c] = (state[r][c] ^ roundKeyState[r][c]) & 0xff; return out; }

// Key expansion
const Rcon=[0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36];
function keyExpansion(keyBytes){ const Nk=4,Nb=4,Nr=10; const w=[]; for(let i=0;i<4;i++) w[i] = keyBytes.slice(4*i,4*i+4); for(let i=4;i<4*(Nr+1);i++){ let temp = w[i-1].slice(); if(i % Nk === 0){ temp.push(temp.shift()); temp = temp.map(b => sbox[b]); temp[0] ^= Rcon[i/Nk]; } w[i] = [0,0,0,0]; for(let j=0;j<4;j++) w[i][j] = w[i-Nk][j] ^ temp[j]; } const roundKeys=[]; for(let r=0;r<=Nr;r++){ const rk=[]; for(let i=0;i<4;i++) rk.push(...w[4*r + i]); roundKeys.push(rk); } return {roundKeys, words:w}; }

function bytesToStateFromKey(bytes){ return bytesToState(bytes); }

// Detailed logging helpers
function byteToLabel(pos){ const r = pos%4, c = Math.floor(pos/4); return `byte[${pos}] (row ${r}, col ${c})`; }

function generateDetailedLogs(ptState,keyState,initAdd,roundKeys,words){ const logs = [];
  // Plaintext matrix bytes list
  logs.push({title:'Input bytes (column-major order)', text: stateToBytes(ptState).map((b,i)=>`${i}: 0x${hexByte(b)}`).join('  ')});
  // Initial AddRoundKey breakdown
  const addLines = [];
  for(let r=0;r<4;r++) for(let c=0;c<4;c++){ const idx = 4*c + r; const a = ptState[r][c], k = keyState[r][c], x = initAdd[r][c]; addLines.push(`${idx}: 0x${hexByte(a)} XOR 0x${hexByte(k)} = 0x${hexByte(x)}`); }
  logs.push({title:'Initial AddRoundKey (byte-by-byte XOR)', text: addLines.join('\n')});
  // Key schedule detailed
  const keyLines = [];
  for(let i=0;i<words.length;i++){ keyLines.push(`w[${i}] = [${words[i].map(b=>'0x'+hexByte(b)).join(', ')}]`); }
  // show derivation around w[4..7] which make roundKey1
  keyLines.push('\nDerivation steps for w[4]..w[7] (to form round key 1):');
  for(let i=4;i<8;i++){
    const prev = words[i-1].slice();
    if(i%4===0){
      const rot = prev.slice(); rot.push(rot.shift());
      const subw = rot.map(b=>sbox[b]);
      const rcon = Rcon[i/4];
      keyLines.push(`w[${i-1}] rot -> RotWord: [${prev.map(b=>'0x'+hexByte(b)).join(', ')}] -> RotWord: [${rot.map(b=>'0x'+hexByte(b)).join(', ')}]`);
      keyLines.push(`SubWord(RotWord): [${subw.map(b=>'0x'+hexByte(b)).join(', ')}], Rcon: 0x${hexByte(rcon)}`);
      const xored = words[i-4].map((wval,j)=> wval ^ subw[j] ^ (j===0 ? rcon : 0));
      keyLines.push(`w[${i}] = w[${i-4}] XOR SubWord(RotWord) XOR Rcon = [${xored.map(b=>'0x'+hexByte(b)).join(', ')}]`);
    } else {
      const xored = words[i-4].map((wval,j)=> wval ^ prev[j]);
      keyLines.push(`w[${i}] = w[${i-4}] XOR w[${i-1}] = [${xored.map(b=>'0x'+hexByte(b)).join(', ')}]`);
    }
  }
  logs.push({title:'Key schedule full words and derivation (w[0]..w[7])', text: keyLines.join('\n')});

  // SubBytes log
  const subLines = [];
  const afterSub = subBytes(initAdd);
  for(let r=0;r<4;r++) for(let c=0;c<4;c++){ const inb = initAdd[r][c]; const outb = afterSub[r][c]; subLines.push(`state[${r}][${c}]: SubBytes(0x${hexByte(inb)}) => S-box[0x${hexByte(inb)}] = 0x${hexByte(outb)}`); }
  logs.push({title:'SubBytes mapping (per byte)', text: subLines.join('\n')});

  // ShiftRows mapping
  const shiftLines = []; const afterShift = shiftRows(afterSub);
  for(let r=0;r<4;r++) for(let c=0;c<4;c++){ const fromCol = (c + (4 - r))%4; const fromVal = afterSub[r][fromCol]; shiftLines.push(`row ${r} col ${c} <= came from col ${fromCol} value 0x${hexByte(fromVal)} -> placed at [${r}][${c}]`); }
  logs.push({title:'ShiftRows mapping (which input moved where)', text: shiftLines.join('\n')});

  // MixColumns detailed per column
  const mixLines=[]; const afterMix = mixColumns(afterShift);
  for(let c=0;c<4;c++){
    const a0=afterShift[0][c], a1=afterShift[1][c], a2=afterShift[2][c], a3=afterShift[3][c];
    mixLines.push(`Column ${c} inputs: a0=0x${hexByte(a0)}, a1=0x${hexByte(a1)}, a2=0x${hexByte(a2)}, a3=0x${hexByte(a3)}`);
    const m0_2 = mul(a0,2); const m1_3 = mul(a1,3); const m2_1 = mul(a2,1); const m3_1 = mul(a3,1);
    mixLines.push(`out0 = 2*${hexByte(a0)} (0x${hexByte(m0_2)}) XOR 3*${hexByte(a1)} (0x${hexByte(m1_3)}) XOR ${hexByte(a2)} (0x${hexByte(m2_1)}) XOR ${hexByte(a3)} (0x${hexByte(m3_1)}) = 0x${hexByte(afterMix[0][c])}`);
    const m0_1 = mul(a0,1); const m1_2 = mul(a1,2); const m2_3 = mul(a2,3); const m3_1b = mul(a3,1);
    mixLines.push(`out1 = 1*${hexByte(a0)} (0x${hexByte(m0_1)}) XOR 2*${hexByte(a1)} (0x${hexByte(m1_2)}) XOR 3*${hexByte(a2)} (0x${hexByte(m2_3)}) XOR 1*${hexByte(a3)} (0x${hexByte(m3_1b)}) = 0x${hexByte(afterMix[1][c])}`);
    const m0_1b = mul(a0,1); const m1_1 = mul(a1,1); const m2_2 = mul(a2,2); const m3_3 = mul(a3,3);
    mixLines.push(`out2 = 1*${hexByte(a0)} (0x${hexByte(m0_1b)}) XOR 1*${hexByte(a1)} (0x${hexByte(m1_1)}) XOR 2*${hexByte(a2)} (0x${hexByte(m2_2)}) XOR 3*${hexByte(a3)} (0x${hexByte(m3_3)}) = 0x${hexByte(afterMix[2][c])}`);
    const m0_3 = mul(a0,3); const m1_1b = mul(a1,1); const m2_1b = mul(a2,1); const m3_2 = mul(a3,2);
    mixLines.push(`out3 = 3*${hexByte(a0)} (0x${hexByte(m0_3)}) XOR 1*${hexByte(a1)} (0x${hexByte(m1_1b)}) XOR 1*${hexByte(a2)} (0x${hexByte(m2_1b)}) XOR 2*${hexByte(a3)} (0x${hexByte(m3_2)}) = 0x${hexByte(afterMix[3][c])}`);
    mixLines.push('');
  }
  logs.push({title:'MixColumns detailed per-column GF(2^8) multiplies and XORs', text: mixLines.join('\n')});

  // AddRoundKey round1
  const k1State = bytesToStateFromKey(roundKeys[1]);
  const add1Lines=[];
  const afterAdd1 = addRoundKey(afterMix,k1State);
  for(let r=0;r<4;r++) for(let c=0;c<4;c++){ add1Lines.push(`state[${r}][${c}]: 0x${hexByte(afterMix[r][c])} XOR k1 0x${hexByte(k1State[r][c])} = 0x${hexByte(afterAdd1[r][c])}`); }
  logs.push({title:'AddRoundKey (Round 1) byte-by-byte', text: add1Lines.join('\n')});

  // final concat
  logs.push({title:'Round 1 output (concatenated hex, column-major)', text: stateToBytes(afterAdd1).map(b=>'0x'+hexByte(b)).join(' ')});

  return logs;
}

// UI wiring
const outDiv = document.getElementById('out'); const detailsDiv = document.getElementById('details'); const err = document.getElementById('err');

document.getElementById('run').addEventListener('click', ()=>{
  err.textContent=''; outDiv.innerHTML=''; detailsDiv.innerHTML='';
  const ptHex = document.getElementById('pt').value; const keyHex = document.getElementById('key').value;
  const ptBytes = parseHex(ptHex); const keyBytes = parseHex(keyHex);
  if(!ptBytes){ err.textContent='Plaintext must be 32 hex characters (0-9a-f).'; return; }
  if(!keyBytes){ err.textContent='Key must be 32 hex characters (0-9a-f).'; return; }

  const ptState = bytesToState(ptBytes); showMatrix('Plaintext state (input matrix)', ptState, outDiv);
  const keyState = bytesToStateFromKey(keyBytes); showMatrix('Key matrix (original key)', keyState, outDiv);

  const initAdd = addRoundKey(ptState,keyState); showMatrix('State after initial AddRoundKey (state^0)', initAdd, outDiv);

  const {roundKeys, words} = keyExpansion(keyBytes); const k1 = roundKeys[1]; const k1State = bytesToStateFromKey(k1);
  showMatrix('Round-1 Key matrix (k1)', k1State, outDiv);

  // Round steps and short matrices
  const afterSub = subBytes(initAdd); showMatrix('After SubBytes', afterSub, outDiv);
  const afterShift = shiftRows(afterSub); showMatrix('After ShiftRows', afterShift, outDiv);
  const afterMix = mixColumns(afterShift); showMatrix('After MixColumns', afterMix, outDiv);
  const afterAddRound1 = addRoundKey(afterMix,k1State); showMatrix('After AddRoundKey (Round 1 result)', afterAddRound1, outDiv);

  // concise final hex
  const finalBytes = stateToBytes(afterAddRound1).map(b=>hexByte(b)).join('');
  const infoCard = document.createElement('div'); infoCard.className='card'; infoCard.innerHTML=`<div class='label'>Round 1 output (concatenated hex)</div><div class='mono'>${finalBytes}</div>`; outDiv.appendChild(infoCard);

  // detailed textual logs
  const logs = generateDetailedLogs(ptState,keyState,initAdd,roundKeys,words);
  logs.forEach(l=>{
    const d = document.createElement('div'); d.className='card'; d.innerHTML = `<details open><summary>${l.title}</summary><pre>${l.text}</pre></details>`; detailsDiv.appendChild(d);
  });

  // Extra section: "Galois (GF) details" — fully explicit operations per multiplication
  const gfCard = document.createElement('div'); gfCard.className='card';
  let gfText = '';
  // show xtime example table for 0x57 (as common AES examples)
  gfText += 'GF(2^8) multiplication helper (xtime) examples:\n';
  const exampleVals = [0x57, 0x83, 0x1b, 0x6e];
  exampleVals.forEach(v=>{ const xt = xtime(v); gfText += `xtime(0x${hexByte(v)}) = 0x${hexByte(xt)}\n`; });
  gfText += '\nMultiplying by constants used in MixColumns (1,2,3):\n';
  exampleVals.forEach(v=>{ gfText += `val 0x${hexByte(v)} *2 = 0x${hexByte(mul(v,2))}, *3 = 0x${hexByte(mul(v,3))}\n`; });
  gfCard.innerHTML = `<div class='label'>Galois-field (GF(2^8)) details</div><pre>${gfText}</pre>`; detailsDiv.appendChild(gfCard);

  // small 'Galileo' easter-egg (the user wrote 'galileo' — we clarify likely meant Galois; still include tiny note)
  const galCard = document.createElement('div'); galCard.className='card'; galCard.innerHTML = `<div class='label'>Note about "Galileo"</div><div class='small'>You asked for "galileo" — if you meant <strong>Galois</strong> (as in Galois field arithmetic used by AES) the detailed GF steps above cover it. If you literally meant the astronomer Galileo, tell me how you'd like him included (e.g., a playful caption or historical note).</div>`; detailsDiv.appendChild(galCard);

});

document.getElementById('fillExample').addEventListener('click', ()=>{ document.getElementById('pt').value='00112233445566778899aabbccddeeff'; document.getElementById('key').value='000102030405060708090a0b0c0d0e0f'; });

</script>
</body>
</html>
